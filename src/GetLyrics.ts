import { Musixmatch } from './Musixmatch';
import { awaitLists } from './index';
import { getLyricLibLyrics, LrcLibResponse } from './LrcLib';
import { LyricsResponse } from './LyricUtils';

const youtubeSnippetAPI = "https://www.googleapis.com/youtube/v3/videos";

type videoMetaType = {
    kind: string,
    etag: string,
    items: [{
        contentDetails: {
            duration: string // ISO 8601
        },
        kind: string,
        etag: string,
        id: string,
        snippet: {
            publishedAt: string,
            channelId: string
            title: string,
            description: string,
            channelType: string
            defaultLanguage: string,
            tags: string[],
            channelTitle: string,
        }
    }]
}

const mx = new Musixmatch();
const cache = caches.default;

export async function getLyrics(request: Request<unknown, IncomingRequestCfProperties<unknown>>, env: Env): Promise<Response> {
    let cachedResponse = await cache.match(request.url);
    if (cachedResponse) {
        console.log({ usingCachedLyrics: true });
        return cachedResponse;
    } else {
        console.log({ usingCachedLyrics: false });
    }

    let params = new URL(request.url).searchParams;
    let artist: string | null | undefined = params.get('artist');
    let song: string | null | undefined = params.get('song');
    let album: string | null = null;
    let duration = params.get('duration');
    let parsedSongAndArtist: string | null = null;
    let videoId = params.get("videoId");
    let description: string | null = null;
    let enhanced = (params.get("enhanced") || "false").toLowerCase() === "true";
    let useLrcLib = (params.get('useLrcLib') || 'false').toLowerCase() === 'true';

    // we'll use this to make sure we control the formatting of multi-artists
    let artists: string[] = [];
    if (artist) {
        artists = artist.split(',')
            .flatMap(a => a.split('&'))
            // .flatMap(a => a.split('and'))
            .map(a => a.trim()).filter(a => a.length > 0);
    }

    console.log({ 'numArtists': artists.length, 'artists': artists });

    if (!videoId) {
        return new Response(JSON.stringify("Invalid Video Id"), { status: 400 });
    }

    // song = cleanupText(song);
    // artist = cleanupText(artist);

    let tokenPromise = mx.getToken();

    let snippetUrl = new URL(youtubeSnippetAPI);
    snippetUrl.searchParams.set("id", videoId);
    snippetUrl.searchParams.set("key", env.GOOGLE_API_KEY);
    snippetUrl.searchParams.set('part', 'snippet,contentDetails');

    let videoMeta: videoMetaType | undefined = await cache.match(snippetUrl).then(response => response?.json());
    if (!videoMeta) {
        videoMeta = await fetch(snippetUrl).then(response => {
            awaitLists.add(cache.put(response.url, response.clone()));
            return response.json();
        });
    }

    if (videoMeta && videoMeta.items && videoMeta.items.length > 0
        && videoMeta.items[0] && videoMeta.items[0].snippet && videoMeta.items[0].contentDetails) {
        let snippet = videoMeta.items[0].snippet;
        if (snippet.description && snippet.description.endsWith("Auto-generated by YouTube.")) {
            description = snippet.description;
            let desc = snippet.description.split("\n");
            if (desc.length > 4) {
                parsedSongAndArtist = desc[2];
                album = desc[4];
            }

            if (parsedSongAndArtist) {
                let splitSongAndArtist = parsedSongAndArtist.split("·");
                song = splitSongAndArtist[0].trim();

                splitSongAndArtist.shift();

                // Check that the original artist is in the metadata list
                let newArtists = splitSongAndArtist;
                if (newArtists.length > 3 && newArtists.length > artists.length) {
                    // We have a lot of artists. This probably means writers/etc are also here.
                    if (snippet.channelTitle && snippet.channelTitle.endsWith('- Topic')) {
                        // Use the channel title instead
                        newArtists = [snippet.channelTitle.substring(0, snippet.channelTitle.length - 7).trim()];
                    } else {
                        newArtists = [newArtists[0]];
                    }
                }

                if (artists.length == 0 || newArtists.includes(artists[0])) {
                    artists = newArtists;
                    artist = artists.join(', ');
                }
            }
        }

        let contentDetails = videoMeta.items[0].contentDetails;
        if (contentDetails && contentDetails.duration) {
            const match = contentDetails.duration.match(/PT(?:(\d+)M)?(?:(\d+)S)?/);
            if (match) {
                const minutes = match[1] ? parseInt(match[1], 10) : 0;
                const seconds = match[2] ? parseInt(match[2], 10) : 0;

                duration = String(60 * minutes + seconds);
            }
        }
    }

    if (!song) {
        return new Response(JSON.stringify({
            message: "A Song wasn't provided and couldn't be inferred",
            song,
            artist,
            album,
            duration,
            parsedSongAndArtist,
            videoId,
            description,
        }), { status: 400 });
    }

    if (!artist) {
        return new Response(JSON.stringify({
            message: "An Artist wasn't provided and couldn't be inferred",
            song,
            artist,
            album,
            duration,
            parsedSongAndArtist,
            videoId,
            description,
        }), { status: 400 });
    }


    let response = {
        song,
        artist,
        album,
        duration,
        parsedSongAndArtist,
        videoId,
        description,
        debugInfo: null as any,
        musixmatchWordByWordLyrics: null as any,
        musixmatchSyncedLyrics: null as any,
        lrclibSyncedLyrics: null as any,
        lrclibPlainLyrics: null as any
    };

    let artistAlbumSongCombos: { artist: string, song: string, album: string | null }[] = [
        {
            artist: artists.join(', '), album, song
        }
    ];

    if (artists.length > 1) {
        artistAlbumSongCombos.push({
            artist: artists[0],
            album,
            song
        });
    }
    if (album !== null) {
        artistAlbumSongCombos.push({
            artist: artists[0],
            album: null,
            song
        });
    }

    await tokenPromise;
    let foundStats = [];
    for (let index in artistAlbumSongCombos) {
        let combo = artistAlbumSongCombos[index];
        let lrcLibLyricsPromise: Promise<LyricsResponse | null> | null = null;
        if (useLrcLib) {
            lrcLibLyricsPromise = getLyricLibLyrics(combo.artist, combo.song, combo.album, duration);
        }

        try {
            let musixmatchLyrics = await mx.getLrc(combo.artist, combo.song, combo.album, enhanced, lrcLibLyricsPromise);
            if (musixmatchLyrics) {
                response.musixmatchWordByWordLyrics = musixmatchLyrics.richSynced;
                response.musixmatchSyncedLyrics = musixmatchLyrics.synced;
                response.debugInfo = musixmatchLyrics.debugInfo;
            }
        } catch (e) {
            console.error(e);
        }

        if (useLrcLib) {
            const lrcLibLyrics = await lrcLibLyricsPromise;
            response.lrclibSyncedLyrics = lrcLibLyrics?.synced;
            response.lrclibPlainLyrics = lrcLibLyrics?.unsynced;
        }

        foundStats.push({
            'hasWordByWord': isTruthy(response.musixmatchWordByWordLyrics),
            'hasLrcLibSynced': isTruthy(response.lrclibSyncedLyrics),
            'hasMusixmatchSynced': isTruthy(response.musixmatchSyncedLyrics),
            'hasLrcLibPlain': isTruthy(response.lrclibPlainLyrics)
        });

        if (isTruthy(response.musixmatchWordByWordLyrics) || isTruthy(response.lrclibSyncedLyrics) || isTruthy(response.musixmatchSyncedLyrics)) {
            response.song = combo.song;
            response.artist = combo.artist;
            response.album = combo.album;
            break;
        }
    }

    console.log({
        foundStats: foundStats,
        foundSyncedLyrics: isTruthy(response.musixmatchWordByWordLyrics) || isTruthy(response.lrclibSyncedLyrics) || isTruthy(response.musixmatchSyncedLyrics),
        foundPlainLyrics: isTruthy(response.lrclibPlainLyrics),
        foundRichSyncedLyrics: isTruthy(response.musixmatchSyncedLyrics),
        foundLyrics: isTruthy(response.musixmatchWordByWordLyrics) || isTruthy(response.lrclibSyncedLyrics) || isTruthy(response.musixmatchSyncedLyrics) || isTruthy(response.lrclibPlainLyrics),
        response: response
    });



    let json = JSON.stringify(response);

    let cacheableResponse = new Response(json, { status: 200 });
    if (response.musixmatchSyncedLyrics || response.lrclibSyncedLyrics) {
        cacheableResponse.headers.set('Cache-control', 'public; max-age=259200');
    } else {
        // cache the request only for a short time
        cacheableResponse.headers.set("Cache-control", "public; max-age=600");
    }
    cacheableResponse.headers.set('Content-Type', 'application/json');
    awaitLists.add(cache.put(request.url, cacheableResponse));

    return new Response(json, { status: 200 });
}


function cleanupText(text: string | null | undefined): string | null | undefined {
    if (!text) return text;

    // Common language-related terms to preserve
    const languageTerms = [
        'ver', 'version', 'remix',
        'english', 'korean', 'japanese', 'chinese',
        'jp', 'kr', 'cn', 'en',
        '日本語', '한국어', '中文', 'español',
        'instrumental', 'vault', 'fast', 'slow',
        'with', 'from', 'acoustic'
    ];
    const languagePattern = new RegExp(languageTerms.join('|'), 'i');

    let result = text;
    let lastResult = '';

    while (result !== lastResult) {
        lastResult = result;
        result = result
            .replace(/\[([^\[\]]*)\]/g, (match, content) => {
                // If it contains language-related terms, keep the brackets
                return languagePattern.test(content) ? match : `(${content})`;
            })
            .replace(/(?!^|\s)\(([^()]*)\)/g, (match, content) => {
                // Handle existing parentheses
                return languagePattern.test(content) ? match : '';
            })
            .replace(/\s+/g, ' ')
            .trim();
    }


    return result;
}

function isTruthy(value: string | null | undefined): boolean {
    return !(value === null || value === undefined);
}

